// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `kernel/apis/EngineAPI.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OpenExternalUrlBody)
pub struct OpenExternalUrlBody {
    // message fields
    // @@protoc_insertion_point(field:OpenExternalUrlBody.url)
    pub url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:OpenExternalUrlBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpenExternalUrlBody {
    fn default() -> &'a OpenExternalUrlBody {
        <OpenExternalUrlBody as ::protobuf::Message>::default_instance()
    }
}

impl OpenExternalUrlBody {
    pub fn new() -> OpenExternalUrlBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &OpenExternalUrlBody| { &m.url },
            |m: &mut OpenExternalUrlBody| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpenExternalUrlBody>(
            "OpenExternalUrlBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpenExternalUrlBody {
    const NAME: &'static str = "OpenExternalUrlBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpenExternalUrlBody {
        OpenExternalUrlBody::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpenExternalUrlBody {
        static instance: OpenExternalUrlBody = OpenExternalUrlBody {
            url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpenExternalUrlBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpenExternalUrlBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpenExternalUrlBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenExternalUrlBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OpenNFTDialogBody)
pub struct OpenNFTDialogBody {
    // message fields
    // @@protoc_insertion_point(field:OpenNFTDialogBody.asset_contract_address)
    pub asset_contract_address: ::std::string::String,
    // @@protoc_insertion_point(field:OpenNFTDialogBody.token_id)
    pub token_id: ::std::string::String,
    // @@protoc_insertion_point(field:OpenNFTDialogBody.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:OpenNFTDialogBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpenNFTDialogBody {
    fn default() -> &'a OpenNFTDialogBody {
        <OpenNFTDialogBody as ::protobuf::Message>::default_instance()
    }
}

impl OpenNFTDialogBody {
    pub fn new() -> OpenNFTDialogBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "asset_contract_address",
            |m: &OpenNFTDialogBody| { &m.asset_contract_address },
            |m: &mut OpenNFTDialogBody| { &mut m.asset_contract_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_id",
            |m: &OpenNFTDialogBody| { &m.token_id },
            |m: &mut OpenNFTDialogBody| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &OpenNFTDialogBody| { &m.comment },
            |m: &mut OpenNFTDialogBody| { &mut m.comment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpenNFTDialogBody>(
            "OpenNFTDialogBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpenNFTDialogBody {
    const NAME: &'static str = "OpenNFTDialogBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.asset_contract_address = is.read_string()?;
                },
                18 => {
                    self.token_id = is.read_string()?;
                },
                26 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.asset_contract_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.asset_contract_address);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.token_id);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.asset_contract_address.is_empty() {
            os.write_string(1, &self.asset_contract_address)?;
        }
        if !self.token_id.is_empty() {
            os.write_string(2, &self.token_id)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpenNFTDialogBody {
        OpenNFTDialogBody::new()
    }

    fn clear(&mut self) {
        self.asset_contract_address.clear();
        self.token_id.clear();
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpenNFTDialogBody {
        static instance: OpenNFTDialogBody = OpenNFTDialogBody {
            asset_contract_address: ::std::string::String::new(),
            token_id: ::std::string::String::new(),
            comment: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpenNFTDialogBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpenNFTDialogBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpenNFTDialogBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenNFTDialogBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CreateEntityBody)
pub struct CreateEntityBody {
    // message fields
    // @@protoc_insertion_point(field:CreateEntityBody.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:CreateEntityBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateEntityBody {
    fn default() -> &'a CreateEntityBody {
        <CreateEntityBody as ::protobuf::Message>::default_instance()
    }
}

impl CreateEntityBody {
    pub fn new() -> CreateEntityBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CreateEntityBody| { &m.id },
            |m: &mut CreateEntityBody| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateEntityBody>(
            "CreateEntityBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateEntityBody {
    const NAME: &'static str = "CreateEntityBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateEntityBody {
        CreateEntityBody::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateEntityBody {
        static instance: CreateEntityBody = CreateEntityBody {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateEntityBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateEntityBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateEntityBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEntityBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RemoveEntityBody)
pub struct RemoveEntityBody {
    // message fields
    // @@protoc_insertion_point(field:RemoveEntityBody.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:RemoveEntityBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveEntityBody {
    fn default() -> &'a RemoveEntityBody {
        <RemoveEntityBody as ::protobuf::Message>::default_instance()
    }
}

impl RemoveEntityBody {
    pub fn new() -> RemoveEntityBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RemoveEntityBody| { &m.id },
            |m: &mut RemoveEntityBody| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveEntityBody>(
            "RemoveEntityBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveEntityBody {
    const NAME: &'static str = "RemoveEntityBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveEntityBody {
        RemoveEntityBody::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveEntityBody {
        static instance: RemoveEntityBody = RemoveEntityBody {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveEntityBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveEntityBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveEntityBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveEntityBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UpdateEntityComponentBody)
pub struct UpdateEntityComponentBody {
    // message fields
    // @@protoc_insertion_point(field:UpdateEntityComponentBody.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateEntityComponentBody.class_id)
    pub class_id: i32,
    // @@protoc_insertion_point(field:UpdateEntityComponentBody.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateEntityComponentBody.json)
    pub json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateEntityComponentBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEntityComponentBody {
    fn default() -> &'a UpdateEntityComponentBody {
        <UpdateEntityComponentBody as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEntityComponentBody {
    pub fn new() -> UpdateEntityComponentBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &UpdateEntityComponentBody| { &m.entity_id },
            |m: &mut UpdateEntityComponentBody| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "class_id",
            |m: &UpdateEntityComponentBody| { &m.class_id },
            |m: &mut UpdateEntityComponentBody| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UpdateEntityComponentBody| { &m.name },
            |m: &mut UpdateEntityComponentBody| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json",
            |m: &UpdateEntityComponentBody| { &m.json },
            |m: &mut UpdateEntityComponentBody| { &mut m.json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEntityComponentBody>(
            "UpdateEntityComponentBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEntityComponentBody {
    const NAME: &'static str = "UpdateEntityComponentBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                16 => {
                    self.class_id = is.read_int32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if self.class_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.class_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.json.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if self.class_id != 0 {
            os.write_int32(2, self.class_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.json.is_empty() {
            os.write_string(4, &self.json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEntityComponentBody {
        UpdateEntityComponentBody::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.class_id = 0;
        self.name.clear();
        self.json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEntityComponentBody {
        static instance: UpdateEntityComponentBody = UpdateEntityComponentBody {
            entity_id: ::std::string::String::new(),
            class_id: 0,
            name: ::std::string::String::new(),
            json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEntityComponentBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEntityComponentBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEntityComponentBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEntityComponentBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AttachEntityComponentBody)
pub struct AttachEntityComponentBody {
    // message fields
    // @@protoc_insertion_point(field:AttachEntityComponentBody.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:AttachEntityComponentBody.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:AttachEntityComponentBody.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:AttachEntityComponentBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttachEntityComponentBody {
    fn default() -> &'a AttachEntityComponentBody {
        <AttachEntityComponentBody as ::protobuf::Message>::default_instance()
    }
}

impl AttachEntityComponentBody {
    pub fn new() -> AttachEntityComponentBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &AttachEntityComponentBody| { &m.entity_id },
            |m: &mut AttachEntityComponentBody| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AttachEntityComponentBody| { &m.name },
            |m: &mut AttachEntityComponentBody| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AttachEntityComponentBody| { &m.id },
            |m: &mut AttachEntityComponentBody| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AttachEntityComponentBody>(
            "AttachEntityComponentBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AttachEntityComponentBody {
    const NAME: &'static str = "AttachEntityComponentBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttachEntityComponentBody {
        AttachEntityComponentBody::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.name.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttachEntityComponentBody {
        static instance: AttachEntityComponentBody = AttachEntityComponentBody {
            entity_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AttachEntityComponentBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AttachEntityComponentBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AttachEntityComponentBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachEntityComponentBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ComponentRemovedBody)
pub struct ComponentRemovedBody {
    // message fields
    // @@protoc_insertion_point(field:ComponentRemovedBody.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:ComponentRemovedBody.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ComponentRemovedBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentRemovedBody {
    fn default() -> &'a ComponentRemovedBody {
        <ComponentRemovedBody as ::protobuf::Message>::default_instance()
    }
}

impl ComponentRemovedBody {
    pub fn new() -> ComponentRemovedBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &ComponentRemovedBody| { &m.entity_id },
            |m: &mut ComponentRemovedBody| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ComponentRemovedBody| { &m.name },
            |m: &mut ComponentRemovedBody| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentRemovedBody>(
            "ComponentRemovedBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentRemovedBody {
    const NAME: &'static str = "ComponentRemovedBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentRemovedBody {
        ComponentRemovedBody::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentRemovedBody {
        static instance: ComponentRemovedBody = ComponentRemovedBody {
            entity_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentRemovedBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentRemovedBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentRemovedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentRemovedBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SetEntityParentBody)
pub struct SetEntityParentBody {
    // message fields
    // @@protoc_insertion_point(field:SetEntityParentBody.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:SetEntityParentBody.parent_id)
    pub parent_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:SetEntityParentBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetEntityParentBody {
    fn default() -> &'a SetEntityParentBody {
        <SetEntityParentBody as ::protobuf::Message>::default_instance()
    }
}

impl SetEntityParentBody {
    pub fn new() -> SetEntityParentBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &SetEntityParentBody| { &m.entity_id },
            |m: &mut SetEntityParentBody| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_id",
            |m: &SetEntityParentBody| { &m.parent_id },
            |m: &mut SetEntityParentBody| { &mut m.parent_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetEntityParentBody>(
            "SetEntityParentBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetEntityParentBody {
    const NAME: &'static str = "SetEntityParentBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.parent_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.parent_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.parent_id.is_empty() {
            os.write_string(2, &self.parent_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetEntityParentBody {
        SetEntityParentBody::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.parent_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetEntityParentBody {
        static instance: SetEntityParentBody = SetEntityParentBody {
            entity_id: ::std::string::String::new(),
            parent_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetEntityParentBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetEntityParentBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetEntityParentBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetEntityParentBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QueryBody)
pub struct QueryBody {
    // message fields
    // @@protoc_insertion_point(field:QueryBody.query_id)
    pub query_id: ::protobuf::EnumOrUnknown<QueryType>,
    // @@protoc_insertion_point(field:QueryBody.payload)
    pub payload: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:QueryBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryBody {
    fn default() -> &'a QueryBody {
        <QueryBody as ::protobuf::Message>::default_instance()
    }
}

impl QueryBody {
    pub fn new() -> QueryBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query_id",
            |m: &QueryBody| { &m.query_id },
            |m: &mut QueryBody| { &mut m.query_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payload",
            |m: &QueryBody| { &m.payload },
            |m: &mut QueryBody| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryBody>(
            "QueryBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryBody {
    const NAME: &'static str = "QueryBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.query_id = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.payload = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.query_id != ::protobuf::EnumOrUnknown::new(QueryType::InvalidQueryType) {
            my_size += ::protobuf::rt::int32_size(1, self.query_id.value());
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.query_id != ::protobuf::EnumOrUnknown::new(QueryType::InvalidQueryType) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.query_id))?;
        }
        if !self.payload.is_empty() {
            os.write_string(2, &self.payload)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryBody {
        QueryBody::new()
    }

    fn clear(&mut self) {
        self.query_id = ::protobuf::EnumOrUnknown::new(QueryType::InvalidQueryType);
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryBody {
        static instance: QueryBody = QueryBody {
            query_id: ::protobuf::EnumOrUnknown::from_i32(0),
            payload: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ComponentCreatedBody)
pub struct ComponentCreatedBody {
    // message fields
    // @@protoc_insertion_point(field:ComponentCreatedBody.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:ComponentCreatedBody.class_id)
    pub class_id: i32,
    // @@protoc_insertion_point(field:ComponentCreatedBody.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ComponentCreatedBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentCreatedBody {
    fn default() -> &'a ComponentCreatedBody {
        <ComponentCreatedBody as ::protobuf::Message>::default_instance()
    }
}

impl ComponentCreatedBody {
    pub fn new() -> ComponentCreatedBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ComponentCreatedBody| { &m.id },
            |m: &mut ComponentCreatedBody| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "class_id",
            |m: &ComponentCreatedBody| { &m.class_id },
            |m: &mut ComponentCreatedBody| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ComponentCreatedBody| { &m.name },
            |m: &mut ComponentCreatedBody| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentCreatedBody>(
            "ComponentCreatedBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentCreatedBody {
    const NAME: &'static str = "ComponentCreatedBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.class_id = is.read_int32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.class_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.class_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.class_id != 0 {
            os.write_int32(2, self.class_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentCreatedBody {
        ComponentCreatedBody::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.class_id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentCreatedBody {
        static instance: ComponentCreatedBody = ComponentCreatedBody {
            id: ::std::string::String::new(),
            class_id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentCreatedBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentCreatedBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentCreatedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentCreatedBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ComponentDisposedBody)
pub struct ComponentDisposedBody {
    // message fields
    // @@protoc_insertion_point(field:ComponentDisposedBody.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ComponentDisposedBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentDisposedBody {
    fn default() -> &'a ComponentDisposedBody {
        <ComponentDisposedBody as ::protobuf::Message>::default_instance()
    }
}

impl ComponentDisposedBody {
    pub fn new() -> ComponentDisposedBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ComponentDisposedBody| { &m.id },
            |m: &mut ComponentDisposedBody| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentDisposedBody>(
            "ComponentDisposedBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentDisposedBody {
    const NAME: &'static str = "ComponentDisposedBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentDisposedBody {
        ComponentDisposedBody::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentDisposedBody {
        static instance: ComponentDisposedBody = ComponentDisposedBody {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentDisposedBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentDisposedBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentDisposedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentDisposedBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ComponentUpdatedBody)
pub struct ComponentUpdatedBody {
    // message fields
    // @@protoc_insertion_point(field:ComponentUpdatedBody.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:ComponentUpdatedBody.json)
    pub json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ComponentUpdatedBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComponentUpdatedBody {
    fn default() -> &'a ComponentUpdatedBody {
        <ComponentUpdatedBody as ::protobuf::Message>::default_instance()
    }
}

impl ComponentUpdatedBody {
    pub fn new() -> ComponentUpdatedBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ComponentUpdatedBody| { &m.id },
            |m: &mut ComponentUpdatedBody| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json",
            |m: &ComponentUpdatedBody| { &m.json },
            |m: &mut ComponentUpdatedBody| { &mut m.json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComponentUpdatedBody>(
            "ComponentUpdatedBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComponentUpdatedBody {
    const NAME: &'static str = "ComponentUpdatedBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.json.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.json.is_empty() {
            os.write_string(2, &self.json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComponentUpdatedBody {
        ComponentUpdatedBody::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComponentUpdatedBody {
        static instance: ComponentUpdatedBody = ComponentUpdatedBody {
            id: ::std::string::String::new(),
            json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComponentUpdatedBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComponentUpdatedBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComponentUpdatedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentUpdatedBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:InitMessagesFinishedBody)
pub struct InitMessagesFinishedBody {
    // special fields
    // @@protoc_insertion_point(special_field:InitMessagesFinishedBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitMessagesFinishedBody {
    fn default() -> &'a InitMessagesFinishedBody {
        <InitMessagesFinishedBody as ::protobuf::Message>::default_instance()
    }
}

impl InitMessagesFinishedBody {
    pub fn new() -> InitMessagesFinishedBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitMessagesFinishedBody>(
            "InitMessagesFinishedBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitMessagesFinishedBody {
    const NAME: &'static str = "InitMessagesFinishedBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitMessagesFinishedBody {
        InitMessagesFinishedBody::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitMessagesFinishedBody {
        static instance: InitMessagesFinishedBody = InitMessagesFinishedBody {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitMessagesFinishedBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitMessagesFinishedBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitMessagesFinishedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitMessagesFinishedBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Payload)
pub struct Payload {
    // message fields
    // @@protoc_insertion_point(field:Payload.open_external_url)
    pub open_external_url: ::protobuf::MessageField<OpenExternalUrlBody>,
    // @@protoc_insertion_point(field:Payload.open_nft_dialog)
    pub open_nft_dialog: ::protobuf::MessageField<OpenNFTDialogBody>,
    // @@protoc_insertion_point(field:Payload.create_entity)
    pub create_entity: ::protobuf::MessageField<CreateEntityBody>,
    // @@protoc_insertion_point(field:Payload.remove_entity)
    pub remove_entity: ::protobuf::MessageField<RemoveEntityBody>,
    // @@protoc_insertion_point(field:Payload.update_entity_component)
    pub update_entity_component: ::protobuf::MessageField<UpdateEntityComponentBody>,
    // @@protoc_insertion_point(field:Payload.attach_entity_component)
    pub attach_entity_component: ::protobuf::MessageField<AttachEntityComponentBody>,
    // @@protoc_insertion_point(field:Payload.component_removed)
    pub component_removed: ::protobuf::MessageField<ComponentRemovedBody>,
    // @@protoc_insertion_point(field:Payload.set_entity_parent)
    pub set_entity_parent: ::protobuf::MessageField<SetEntityParentBody>,
    // @@protoc_insertion_point(field:Payload.query)
    pub query: ::protobuf::MessageField<QueryBody>,
    // @@protoc_insertion_point(field:Payload.component_created)
    pub component_created: ::protobuf::MessageField<ComponentCreatedBody>,
    // @@protoc_insertion_point(field:Payload.component_disposed)
    pub component_disposed: ::protobuf::MessageField<ComponentDisposedBody>,
    // @@protoc_insertion_point(field:Payload.component_updated)
    pub component_updated: ::protobuf::MessageField<ComponentUpdatedBody>,
    // @@protoc_insertion_point(field:Payload.init_messages_finished)
    pub init_messages_finished: ::protobuf::MessageField<InitMessagesFinishedBody>,
    // special fields
    // @@protoc_insertion_point(special_field:Payload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OpenExternalUrlBody>(
            "open_external_url",
            |m: &Payload| { &m.open_external_url },
            |m: &mut Payload| { &mut m.open_external_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OpenNFTDialogBody>(
            "open_nft_dialog",
            |m: &Payload| { &m.open_nft_dialog },
            |m: &mut Payload| { &mut m.open_nft_dialog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CreateEntityBody>(
            "create_entity",
            |m: &Payload| { &m.create_entity },
            |m: &mut Payload| { &mut m.create_entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoveEntityBody>(
            "remove_entity",
            |m: &Payload| { &m.remove_entity },
            |m: &mut Payload| { &mut m.remove_entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UpdateEntityComponentBody>(
            "update_entity_component",
            |m: &Payload| { &m.update_entity_component },
            |m: &mut Payload| { &mut m.update_entity_component },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AttachEntityComponentBody>(
            "attach_entity_component",
            |m: &Payload| { &m.attach_entity_component },
            |m: &mut Payload| { &mut m.attach_entity_component },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComponentRemovedBody>(
            "component_removed",
            |m: &Payload| { &m.component_removed },
            |m: &mut Payload| { &mut m.component_removed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SetEntityParentBody>(
            "set_entity_parent",
            |m: &Payload| { &m.set_entity_parent },
            |m: &mut Payload| { &mut m.set_entity_parent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QueryBody>(
            "query",
            |m: &Payload| { &m.query },
            |m: &mut Payload| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComponentCreatedBody>(
            "component_created",
            |m: &Payload| { &m.component_created },
            |m: &mut Payload| { &mut m.component_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComponentDisposedBody>(
            "component_disposed",
            |m: &Payload| { &m.component_disposed },
            |m: &mut Payload| { &mut m.component_disposed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComponentUpdatedBody>(
            "component_updated",
            |m: &Payload| { &m.component_updated },
            |m: &mut Payload| { &mut m.component_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InitMessagesFinishedBody>(
            "init_messages_finished",
            |m: &Payload| { &m.init_messages_finished },
            |m: &mut Payload| { &mut m.init_messages_finished },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payload>(
            "Payload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Payload {
    const NAME: &'static str = "Payload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.open_external_url)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.open_nft_dialog)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.create_entity)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.remove_entity)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_entity_component)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attach_entity_component)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.component_removed)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_entity_parent)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.component_created)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.component_disposed)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.component_updated)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.init_messages_finished)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.open_external_url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.open_nft_dialog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.create_entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remove_entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_entity_component.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.attach_entity_component.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.component_removed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_entity_parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.component_created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.component_disposed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.component_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.init_messages_finished.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.open_external_url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.open_nft_dialog.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.create_entity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.remove_entity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.update_entity_component.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.attach_entity_component.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.component_removed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.set_entity_parent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.component_created.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.component_disposed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.component_updated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.init_messages_finished.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn clear(&mut self) {
        self.open_external_url.clear();
        self.open_nft_dialog.clear();
        self.create_entity.clear();
        self.remove_entity.clear();
        self.update_entity_component.clear();
        self.attach_entity_component.clear();
        self.component_removed.clear();
        self.set_entity_parent.clear();
        self.query.clear();
        self.component_created.clear();
        self.component_disposed.clear();
        self.component_updated.clear();
        self.init_messages_finished.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payload {
        static instance: Payload = Payload {
            open_external_url: ::protobuf::MessageField::none(),
            open_nft_dialog: ::protobuf::MessageField::none(),
            create_entity: ::protobuf::MessageField::none(),
            remove_entity: ::protobuf::MessageField::none(),
            update_entity_component: ::protobuf::MessageField::none(),
            attach_entity_component: ::protobuf::MessageField::none(),
            component_removed: ::protobuf::MessageField::none(),
            set_entity_parent: ::protobuf::MessageField::none(),
            query: ::protobuf::MessageField::none(),
            component_created: ::protobuf::MessageField::none(),
            component_disposed: ::protobuf::MessageField::none(),
            component_updated: ::protobuf::MessageField::none(),
            init_messages_finished: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Payload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EntityAction)
pub struct EntityAction {
    // message fields
    // @@protoc_insertion_point(field:EntityAction.type)
    pub type_: ::protobuf::EnumOrUnknown<EAType>,
    // @@protoc_insertion_point(field:EntityAction.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:EntityAction.payload)
    pub payload: ::protobuf::MessageField<Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:EntityAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EntityAction {
    fn default() -> &'a EntityAction {
        <EntityAction as ::protobuf::Message>::default_instance()
    }
}

impl EntityAction {
    pub fn new() -> EntityAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &EntityAction| { &m.type_ },
            |m: &mut EntityAction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &EntityAction| { &m.tag },
            |m: &mut EntityAction| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payload>(
            "payload",
            |m: &EntityAction| { &m.payload },
            |m: &mut EntityAction| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EntityAction>(
            "EntityAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EntityAction {
    const NAME: &'static str = "EntityAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(EAType::InvalidEAType) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(EAType::InvalidEAType) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EntityAction {
        EntityAction::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(EAType::InvalidEAType);
        self.tag = ::std::option::Option::None;
        self.payload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EntityAction {
        static instance: EntityAction = EntityAction {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            tag: ::std::option::Option::None,
            payload: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EntityAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EntityAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EntityAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ManyEntityAction)
pub struct ManyEntityAction {
    // message fields
    // @@protoc_insertion_point(field:ManyEntityAction.actions)
    pub actions: ::std::vec::Vec<EntityAction>,
    // special fields
    // @@protoc_insertion_point(special_field:ManyEntityAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ManyEntityAction {
    fn default() -> &'a ManyEntityAction {
        <ManyEntityAction as ::protobuf::Message>::default_instance()
    }
}

impl ManyEntityAction {
    pub fn new() -> ManyEntityAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &ManyEntityAction| { &m.actions },
            |m: &mut ManyEntityAction| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManyEntityAction>(
            "ManyEntityAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ManyEntityAction {
    const NAME: &'static str = "ManyEntityAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ManyEntityAction {
        ManyEntityAction::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ManyEntityAction {
        static instance: ManyEntityAction = ManyEntityAction {
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ManyEntityAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ManyEntityAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ManyEntityAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManyEntityAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SendBatchResponse)
pub struct SendBatchResponse {
    // message fields
    // @@protoc_insertion_point(field:SendBatchResponse.events)
    pub events: ::std::vec::Vec<EventData>,
    // special fields
    // @@protoc_insertion_point(special_field:SendBatchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendBatchResponse {
    fn default() -> &'a SendBatchResponse {
        <SendBatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendBatchResponse {
    pub fn new() -> SendBatchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &SendBatchResponse| { &m.events },
            |m: &mut SendBatchResponse| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendBatchResponse>(
            "SendBatchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendBatchResponse {
    const NAME: &'static str = "SendBatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendBatchResponse {
        SendBatchResponse::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendBatchResponse {
        static instance: SendBatchResponse = SendBatchResponse {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendBatchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendBatchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendBatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendBatchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UnsubscribeRequest)
pub struct UnsubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:UnsubscribeRequest.event_id)
    pub event_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:UnsubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnsubscribeRequest {
    fn default() -> &'a UnsubscribeRequest {
        <UnsubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnsubscribeRequest {
    pub fn new() -> UnsubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_id",
            |m: &UnsubscribeRequest| { &m.event_id },
            |m: &mut UnsubscribeRequest| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsubscribeRequest>(
            "UnsubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnsubscribeRequest {
    const NAME: &'static str = "UnsubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.event_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.event_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.event_id.is_empty() {
            os.write_string(1, &self.event_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnsubscribeRequest {
        UnsubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.event_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnsubscribeRequest {
        static instance: UnsubscribeRequest = UnsubscribeRequest {
            event_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnsubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnsubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnsubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeRequest)
pub struct SubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeRequest.event_id)
    pub event_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_id",
            |m: &SubscribeRequest| { &m.event_id },
            |m: &mut SubscribeRequest| { &mut m.event_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeRequest>(
            "SubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeRequest {
    const NAME: &'static str = "SubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.event_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.event_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.event_id.is_empty() {
            os.write_string(1, &self.event_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.event_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: SubscribeRequest = SubscribeRequest {
            event_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeResponse)
pub struct SubscribeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeResponse {
    fn default() -> &'a SubscribeResponse {
        <SubscribeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeResponse {
    pub fn new() -> SubscribeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeResponse>(
            "SubscribeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeResponse {
    const NAME: &'static str = "SubscribeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeResponse {
        SubscribeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeResponse {
        static instance: SubscribeResponse = SubscribeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UnsubscribeResponse)
pub struct UnsubscribeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:UnsubscribeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnsubscribeResponse {
    fn default() -> &'a UnsubscribeResponse {
        <UnsubscribeResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnsubscribeResponse {
    pub fn new() -> UnsubscribeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsubscribeResponse>(
            "UnsubscribeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnsubscribeResponse {
    const NAME: &'static str = "UnsubscribeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnsubscribeResponse {
        UnsubscribeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnsubscribeResponse {
        static instance: UnsubscribeResponse = UnsubscribeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnsubscribeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnsubscribeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnsubscribeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsubscribeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GenericPayload)
pub struct GenericPayload {
    // message fields
    // @@protoc_insertion_point(field:GenericPayload.event_id)
    pub event_id: ::std::string::String,
    // @@protoc_insertion_point(field:GenericPayload.event_data)
    pub event_data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:GenericPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericPayload {
    fn default() -> &'a GenericPayload {
        <GenericPayload as ::protobuf::Message>::default_instance()
    }
}

impl GenericPayload {
    pub fn new() -> GenericPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_id",
            |m: &GenericPayload| { &m.event_id },
            |m: &mut GenericPayload| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_data",
            |m: &GenericPayload| { &m.event_data },
            |m: &mut GenericPayload| { &mut m.event_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericPayload>(
            "GenericPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericPayload {
    const NAME: &'static str = "GenericPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.event_id = is.read_string()?;
                },
                34 => {
                    self.event_data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.event_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.event_id);
        }
        if !self.event_data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.event_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.event_id.is_empty() {
            os.write_string(3, &self.event_id)?;
        }
        if !self.event_data.is_empty() {
            os.write_string(4, &self.event_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericPayload {
        GenericPayload::new()
    }

    fn clear(&mut self) {
        self.event_id.clear();
        self.event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericPayload {
        static instance: GenericPayload = GenericPayload {
            event_id: ::std::string::String::new(),
            event_data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ReadOnlyVector3)
pub struct ReadOnlyVector3 {
    // message fields
    // @@protoc_insertion_point(field:ReadOnlyVector3.x)
    pub x: f32,
    // @@protoc_insertion_point(field:ReadOnlyVector3.y)
    pub y: f32,
    // @@protoc_insertion_point(field:ReadOnlyVector3.z)
    pub z: f32,
    // special fields
    // @@protoc_insertion_point(special_field:ReadOnlyVector3.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadOnlyVector3 {
    fn default() -> &'a ReadOnlyVector3 {
        <ReadOnlyVector3 as ::protobuf::Message>::default_instance()
    }
}

impl ReadOnlyVector3 {
    pub fn new() -> ReadOnlyVector3 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &ReadOnlyVector3| { &m.x },
            |m: &mut ReadOnlyVector3| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &ReadOnlyVector3| { &m.y },
            |m: &mut ReadOnlyVector3| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "z",
            |m: &ReadOnlyVector3| { &m.z },
            |m: &mut ReadOnlyVector3| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadOnlyVector3>(
            "ReadOnlyVector3",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadOnlyVector3 {
    const NAME: &'static str = "ReadOnlyVector3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = is.read_float()?;
                },
                21 => {
                    self.y = is.read_float()?;
                },
                29 => {
                    self.z = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 4;
        }
        if self.y != 0. {
            my_size += 1 + 4;
        }
        if self.z != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadOnlyVector3 {
        ReadOnlyVector3::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadOnlyVector3 {
        static instance: ReadOnlyVector3 = ReadOnlyVector3 {
            x: 0.,
            y: 0.,
            z: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadOnlyVector3 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadOnlyVector3").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadOnlyVector3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOnlyVector3 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ReadOnlyQuaternion)
pub struct ReadOnlyQuaternion {
    // message fields
    // @@protoc_insertion_point(field:ReadOnlyQuaternion.x)
    pub x: f32,
    // @@protoc_insertion_point(field:ReadOnlyQuaternion.y)
    pub y: f32,
    // @@protoc_insertion_point(field:ReadOnlyQuaternion.z)
    pub z: f32,
    // @@protoc_insertion_point(field:ReadOnlyQuaternion.w)
    pub w: f32,
    // special fields
    // @@protoc_insertion_point(special_field:ReadOnlyQuaternion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadOnlyQuaternion {
    fn default() -> &'a ReadOnlyQuaternion {
        <ReadOnlyQuaternion as ::protobuf::Message>::default_instance()
    }
}

impl ReadOnlyQuaternion {
    pub fn new() -> ReadOnlyQuaternion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &ReadOnlyQuaternion| { &m.x },
            |m: &mut ReadOnlyQuaternion| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &ReadOnlyQuaternion| { &m.y },
            |m: &mut ReadOnlyQuaternion| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "z",
            |m: &ReadOnlyQuaternion| { &m.z },
            |m: &mut ReadOnlyQuaternion| { &mut m.z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "w",
            |m: &ReadOnlyQuaternion| { &m.w },
            |m: &mut ReadOnlyQuaternion| { &mut m.w },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadOnlyQuaternion>(
            "ReadOnlyQuaternion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadOnlyQuaternion {
    const NAME: &'static str = "ReadOnlyQuaternion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = is.read_float()?;
                },
                21 => {
                    self.y = is.read_float()?;
                },
                29 => {
                    self.z = is.read_float()?;
                },
                37 => {
                    self.w = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 4;
        }
        if self.y != 0. {
            my_size += 1 + 4;
        }
        if self.z != 0. {
            my_size += 1 + 4;
        }
        if self.w != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_float(1, self.x)?;
        }
        if self.y != 0. {
            os.write_float(2, self.y)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        if self.w != 0. {
            os.write_float(4, self.w)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadOnlyQuaternion {
        ReadOnlyQuaternion::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.w = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadOnlyQuaternion {
        static instance: ReadOnlyQuaternion = ReadOnlyQuaternion {
            x: 0.,
            y: 0.,
            z: 0.,
            w: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadOnlyQuaternion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadOnlyQuaternion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadOnlyQuaternion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOnlyQuaternion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PositionChangedPayload)
pub struct PositionChangedPayload {
    // message fields
    // @@protoc_insertion_point(field:PositionChangedPayload.position)
    pub position: ::protobuf::MessageField<ReadOnlyVector3>,
    // @@protoc_insertion_point(field:PositionChangedPayload.camera_position)
    pub camera_position: ::protobuf::MessageField<ReadOnlyVector3>,
    // @@protoc_insertion_point(field:PositionChangedPayload.player_height)
    pub player_height: f32,
    // special fields
    // @@protoc_insertion_point(special_field:PositionChangedPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PositionChangedPayload {
    fn default() -> &'a PositionChangedPayload {
        <PositionChangedPayload as ::protobuf::Message>::default_instance()
    }
}

impl PositionChangedPayload {
    pub fn new() -> PositionChangedPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReadOnlyVector3>(
            "position",
            |m: &PositionChangedPayload| { &m.position },
            |m: &mut PositionChangedPayload| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReadOnlyVector3>(
            "camera_position",
            |m: &PositionChangedPayload| { &m.camera_position },
            |m: &mut PositionChangedPayload| { &mut m.camera_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "player_height",
            |m: &PositionChangedPayload| { &m.player_height },
            |m: &mut PositionChangedPayload| { &mut m.player_height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionChangedPayload>(
            "PositionChangedPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PositionChangedPayload {
    const NAME: &'static str = "PositionChangedPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.camera_position)?;
                },
                29 => {
                    self.player_height = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.camera_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.player_height != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.camera_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.player_height != 0. {
            os.write_float(3, self.player_height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PositionChangedPayload {
        PositionChangedPayload::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.camera_position.clear();
        self.player_height = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PositionChangedPayload {
        static instance: PositionChangedPayload = PositionChangedPayload {
            position: ::protobuf::MessageField::none(),
            camera_position: ::protobuf::MessageField::none(),
            player_height: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PositionChangedPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PositionChangedPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PositionChangedPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionChangedPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RotationChangedPayload)
pub struct RotationChangedPayload {
    // message fields
    // @@protoc_insertion_point(field:RotationChangedPayload.rotation)
    pub rotation: ::protobuf::MessageField<ReadOnlyVector3>,
    // @@protoc_insertion_point(field:RotationChangedPayload.quaternion)
    pub quaternion: ::protobuf::MessageField<ReadOnlyQuaternion>,
    // special fields
    // @@protoc_insertion_point(special_field:RotationChangedPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RotationChangedPayload {
    fn default() -> &'a RotationChangedPayload {
        <RotationChangedPayload as ::protobuf::Message>::default_instance()
    }
}

impl RotationChangedPayload {
    pub fn new() -> RotationChangedPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReadOnlyVector3>(
            "rotation",
            |m: &RotationChangedPayload| { &m.rotation },
            |m: &mut RotationChangedPayload| { &mut m.rotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReadOnlyQuaternion>(
            "quaternion",
            |m: &RotationChangedPayload| { &m.quaternion },
            |m: &mut RotationChangedPayload| { &mut m.quaternion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RotationChangedPayload>(
            "RotationChangedPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RotationChangedPayload {
    const NAME: &'static str = "RotationChangedPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quaternion)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quaternion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RotationChangedPayload {
        RotationChangedPayload::new()
    }

    fn clear(&mut self) {
        self.rotation.clear();
        self.quaternion.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RotationChangedPayload {
        static instance: RotationChangedPayload = RotationChangedPayload {
            rotation: ::protobuf::MessageField::none(),
            quaternion: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RotationChangedPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RotationChangedPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RotationChangedPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RotationChangedPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EventData)
pub struct EventData {
    // message fields
    // @@protoc_insertion_point(field:EventData.type)
    pub type_: ::protobuf::EnumOrUnknown<EventDataType>,
    // @@protoc_insertion_point(field:EventData.generic)
    pub generic: ::protobuf::MessageField<GenericPayload>,
    // @@protoc_insertion_point(field:EventData.position_changed)
    pub position_changed: ::protobuf::MessageField<PositionChangedPayload>,
    // @@protoc_insertion_point(field:EventData.rotation_changed)
    pub rotation_changed: ::protobuf::MessageField<RotationChangedPayload>,
    // special fields
    // @@protoc_insertion_point(special_field:EventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventData {
    fn default() -> &'a EventData {
        <EventData as ::protobuf::Message>::default_instance()
    }
}

impl EventData {
    pub fn new() -> EventData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &EventData| { &m.type_ },
            |m: &mut EventData| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GenericPayload>(
            "generic",
            |m: &EventData| { &m.generic },
            |m: &mut EventData| { &mut m.generic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PositionChangedPayload>(
            "position_changed",
            |m: &EventData| { &m.position_changed },
            |m: &mut EventData| { &mut m.position_changed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RotationChangedPayload>(
            "rotation_changed",
            |m: &EventData| { &m.rotation_changed },
            |m: &mut EventData| { &mut m.rotation_changed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventData>(
            "EventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventData {
    const NAME: &'static str = "EventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.generic)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position_changed)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rotation_changed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(EventDataType::Generic) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.generic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.position_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rotation_changed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(EventDataType::Generic) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.generic.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.position_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.rotation_changed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventData {
        EventData::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(EventDataType::Generic);
        self.generic.clear();
        self.position_changed.clear();
        self.rotation_changed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventData {
        static instance: EventData = EventData {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            generic: ::protobuf::MessageField::none(),
            position_changed: ::protobuf::MessageField::none(),
            rotation_changed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:QueryType)
pub enum QueryType {
    // @@protoc_insertion_point(enum_value:QueryType.InvalidQueryType)
    InvalidQueryType = 0,
    // @@protoc_insertion_point(enum_value:QueryType.HitFirst)
    HitFirst = 1,
    // @@protoc_insertion_point(enum_value:QueryType.HitAll)
    HitAll = 2,
    // @@protoc_insertion_point(enum_value:QueryType.HitFirstAvatar)
    HitFirstAvatar = 3,
    // @@protoc_insertion_point(enum_value:QueryType.HitAllAvatars)
    HitAllAvatars = 4,
}

impl ::protobuf::Enum for QueryType {
    const NAME: &'static str = "QueryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QueryType> {
        match value {
            0 => ::std::option::Option::Some(QueryType::InvalidQueryType),
            1 => ::std::option::Option::Some(QueryType::HitFirst),
            2 => ::std::option::Option::Some(QueryType::HitAll),
            3 => ::std::option::Option::Some(QueryType::HitFirstAvatar),
            4 => ::std::option::Option::Some(QueryType::HitAllAvatars),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [QueryType] = &[
        QueryType::InvalidQueryType,
        QueryType::HitFirst,
        QueryType::HitAll,
        QueryType::HitFirstAvatar,
        QueryType::HitAllAvatars,
    ];
}

impl ::protobuf::EnumFull for QueryType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("QueryType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for QueryType {
    fn default() -> Self {
        QueryType::InvalidQueryType
    }
}

impl QueryType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<QueryType>("QueryType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAType)
pub enum EAType {
    // @@protoc_insertion_point(enum_value:EAType.InvalidEAType)
    InvalidEAType = 0,
    // @@protoc_insertion_point(enum_value:EAType.OpenExternalUrl)
    OpenExternalUrl = 1,
    // @@protoc_insertion_point(enum_value:EAType.OpenNFTDialog)
    OpenNFTDialog = 2,
    // @@protoc_insertion_point(enum_value:EAType.CreateEntity)
    CreateEntity = 3,
    // @@protoc_insertion_point(enum_value:EAType.RemoveEntity)
    RemoveEntity = 4,
    // @@protoc_insertion_point(enum_value:EAType.UpdateEntityComponent)
    UpdateEntityComponent = 5,
    // @@protoc_insertion_point(enum_value:EAType.AttachEntityComponent)
    AttachEntityComponent = 6,
    // @@protoc_insertion_point(enum_value:EAType.ComponentRemoved)
    ComponentRemoved = 7,
    // @@protoc_insertion_point(enum_value:EAType.SetEntityParent)
    SetEntityParent = 8,
    // @@protoc_insertion_point(enum_value:EAType.Query)
    Query = 9,
    // @@protoc_insertion_point(enum_value:EAType.ComponentCreated)
    ComponentCreated = 10,
    // @@protoc_insertion_point(enum_value:EAType.ComponentDisposed)
    ComponentDisposed = 11,
    // @@protoc_insertion_point(enum_value:EAType.ComponentUpdated)
    ComponentUpdated = 12,
    // @@protoc_insertion_point(enum_value:EAType.InitMessagesFinished)
    InitMessagesFinished = 13,
}

impl ::protobuf::Enum for EAType {
    const NAME: &'static str = "EAType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAType> {
        match value {
            0 => ::std::option::Option::Some(EAType::InvalidEAType),
            1 => ::std::option::Option::Some(EAType::OpenExternalUrl),
            2 => ::std::option::Option::Some(EAType::OpenNFTDialog),
            3 => ::std::option::Option::Some(EAType::CreateEntity),
            4 => ::std::option::Option::Some(EAType::RemoveEntity),
            5 => ::std::option::Option::Some(EAType::UpdateEntityComponent),
            6 => ::std::option::Option::Some(EAType::AttachEntityComponent),
            7 => ::std::option::Option::Some(EAType::ComponentRemoved),
            8 => ::std::option::Option::Some(EAType::SetEntityParent),
            9 => ::std::option::Option::Some(EAType::Query),
            10 => ::std::option::Option::Some(EAType::ComponentCreated),
            11 => ::std::option::Option::Some(EAType::ComponentDisposed),
            12 => ::std::option::Option::Some(EAType::ComponentUpdated),
            13 => ::std::option::Option::Some(EAType::InitMessagesFinished),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAType] = &[
        EAType::InvalidEAType,
        EAType::OpenExternalUrl,
        EAType::OpenNFTDialog,
        EAType::CreateEntity,
        EAType::RemoveEntity,
        EAType::UpdateEntityComponent,
        EAType::AttachEntityComponent,
        EAType::ComponentRemoved,
        EAType::SetEntityParent,
        EAType::Query,
        EAType::ComponentCreated,
        EAType::ComponentDisposed,
        EAType::ComponentUpdated,
        EAType::InitMessagesFinished,
    ];
}

impl ::protobuf::EnumFull for EAType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EAType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EAType {
    fn default() -> Self {
        EAType::InvalidEAType
    }
}

impl EAType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EAType>("EAType")
    }
}

///  Events
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EventDataType)
pub enum EventDataType {
    // @@protoc_insertion_point(enum_value:EventDataType.Generic)
    Generic = 0,
    // @@protoc_insertion_point(enum_value:EventDataType.PositionChanged)
    PositionChanged = 1,
    // @@protoc_insertion_point(enum_value:EventDataType.RotationChanged)
    RotationChanged = 2,
}

impl ::protobuf::Enum for EventDataType {
    const NAME: &'static str = "EventDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventDataType> {
        match value {
            0 => ::std::option::Option::Some(EventDataType::Generic),
            1 => ::std::option::Option::Some(EventDataType::PositionChanged),
            2 => ::std::option::Option::Some(EventDataType::RotationChanged),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EventDataType] = &[
        EventDataType::Generic,
        EventDataType::PositionChanged,
        EventDataType::RotationChanged,
    ];
}

impl ::protobuf::EnumFull for EventDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EventDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EventDataType {
    fn default() -> Self {
        EventDataType::Generic
    }
}

impl EventDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EventDataType>("EventDataType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bkernel/apis/EngineAPI.proto\"'\n\x13OpenExternalUrlBody\x12\x10\n\
    \x03url\x18\x01\x20\x01(\tR\x03url\"\x8f\x01\n\x11OpenNFTDialogBody\x124\
    \n\x16asset_contract_address\x18\x01\x20\x01(\tR\x14assetContractAddress\
    \x12\x19\n\x08token_id\x18\x02\x20\x01(\tR\x07tokenId\x12\x1d\n\x07comme\
    nt\x18\x03\x20\x01(\tH\0R\x07comment\x88\x01\x01B\n\n\x08_comment\"\"\n\
    \x10CreateEntityBody\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\"\n\x10\
    RemoveEntityBody\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"{\n\x19Updat\
    eEntityComponentBody\x12\x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityI\
    d\x12\x19\n\x08class_id\x18\x02\x20\x01(\x05R\x07classId\x12\x12\n\x04na\
    me\x18\x03\x20\x01(\tR\x04name\x12\x12\n\x04json\x18\x04\x20\x01(\tR\x04\
    json\"\\\n\x19AttachEntityComponentBody\x12\x1b\n\tentity_id\x18\x01\x20\
    \x01(\tR\x08entityId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\"G\n\x14ComponentRemovedBody\x12\
    \x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"O\n\x13SetEntityParentBody\x12\x1b\n\tentity_i\
    d\x18\x01\x20\x01(\tR\x08entityId\x12\x1b\n\tparent_id\x18\x02\x20\x01(\
    \tR\x08parentId\"L\n\tQueryBody\x12%\n\x08query_id\x18\x01\x20\x01(\x0e2\
    \n.QueryTypeR\x07queryId\x12\x18\n\x07payload\x18\x02\x20\x01(\tR\x07pay\
    load\"U\n\x14ComponentCreatedBody\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x19\n\x08class_id\x18\x02\x20\x01(\x05R\x07classId\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\"'\n\x15ComponentDisposedBody\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\":\n\x14ComponentUpdatedBody\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04json\x18\x02\x20\x01\
    (\tR\x04json\"\x1a\n\x18InitMessagesFinishedBody\"\xc2\t\n\x07Payload\
    \x12E\n\x11open_external_url\x18\x01\x20\x01(\x0b2\x14.OpenExternalUrlBo\
    dyH\0R\x0fopenExternalUrl\x88\x01\x01\x12?\n\x0fopen_nft_dialog\x18\x02\
    \x20\x01(\x0b2\x12.OpenNFTDialogBodyH\x01R\ropenNftDialog\x88\x01\x01\
    \x12;\n\rcreate_entity\x18\x03\x20\x01(\x0b2\x11.CreateEntityBodyH\x02R\
    \x0ccreateEntity\x88\x01\x01\x12;\n\rremove_entity\x18\x04\x20\x01(\x0b2\
    \x11.RemoveEntityBodyH\x03R\x0cremoveEntity\x88\x01\x01\x12W\n\x17update\
    _entity_component\x18\x05\x20\x01(\x0b2\x1a.UpdateEntityComponentBodyH\
    \x04R\x15updateEntityComponent\x88\x01\x01\x12W\n\x17attach_entity_compo\
    nent\x18\x06\x20\x01(\x0b2\x1a.AttachEntityComponentBodyH\x05R\x15attach\
    EntityComponent\x88\x01\x01\x12G\n\x11component_removed\x18\x07\x20\x01(\
    \x0b2\x15.ComponentRemovedBodyH\x06R\x10componentRemoved\x88\x01\x01\x12\
    E\n\x11set_entity_parent\x18\x08\x20\x01(\x0b2\x14.SetEntityParentBodyH\
    \x07R\x0fsetEntityParent\x88\x01\x01\x12%\n\x05query\x18\t\x20\x01(\x0b2\
    \n.QueryBodyH\x08R\x05query\x88\x01\x01\x12G\n\x11component_created\x18\
    \n\x20\x01(\x0b2\x15.ComponentCreatedBodyH\tR\x10componentCreated\x88\
    \x01\x01\x12J\n\x12component_disposed\x18\x0b\x20\x01(\x0b2\x16.Componen\
    tDisposedBodyH\nR\x11componentDisposed\x88\x01\x01\x12G\n\x11component_u\
    pdated\x18\x0c\x20\x01(\x0b2\x15.ComponentUpdatedBodyH\x0bR\x10component\
    Updated\x88\x01\x01\x12T\n\x16init_messages_finished\x18\r\x20\x01(\x0b2\
    \x19.InitMessagesFinishedBodyH\x0cR\x14initMessagesFinished\x88\x01\x01B\
    \x14\n\x12_open_external_urlB\x12\n\x10_open_nft_dialogB\x10\n\x0e_creat\
    e_entityB\x10\n\x0e_remove_entityB\x1a\n\x18_update_entity_componentB\
    \x1a\n\x18_attach_entity_componentB\x14\n\x12_component_removedB\x14\n\
    \x12_set_entity_parentB\x08\n\x06_queryB\x14\n\x12_component_createdB\
    \x15\n\x13_component_disposedB\x14\n\x12_component_updatedB\x19\n\x17_in\
    it_messages_finished\"n\n\x0cEntityAction\x12\x1b\n\x04type\x18\x01\x20\
    \x01(\x0e2\x07.EATypeR\x04type\x12\x15\n\x03tag\x18\x02\x20\x01(\tH\0R\
    \x03tag\x88\x01\x01\x12\"\n\x07payload\x18\x03\x20\x01(\x0b2\x08.Payload\
    R\x07payloadB\x06\n\x04_tag\";\n\x10ManyEntityAction\x12'\n\x07actions\
    \x18\x01\x20\x03(\x0b2\r.EntityActionR\x07actions\"7\n\x11SendBatchRespo\
    nse\x12\"\n\x06events\x18\x01\x20\x03(\x0b2\n.EventDataR\x06events\"/\n\
    \x12UnsubscribeRequest\x12\x19\n\x08event_id\x18\x01\x20\x01(\tR\x07even\
    tId\"-\n\x10SubscribeRequest\x12\x19\n\x08event_id\x18\x01\x20\x01(\tR\
    \x07eventId\"\x13\n\x11SubscribeResponse\"\x15\n\x13UnsubscribeResponse\
    \"J\n\x0eGenericPayload\x12\x19\n\x08event_id\x18\x03\x20\x01(\tR\x07eve\
    ntId\x12\x1d\n\nevent_data\x18\x04\x20\x01(\tR\teventData\";\n\x0fReadOn\
    lyVector3\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\"L\n\
    \x12ReadOnlyQuaternion\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\
    \n\x01y\x18\x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\
    \x01z\x12\x0c\n\x01w\x18\x04\x20\x01(\x02R\x01w\"\xa6\x01\n\x16PositionC\
    hangedPayload\x12,\n\x08position\x18\x01\x20\x01(\x0b2\x10.ReadOnlyVecto\
    r3R\x08position\x129\n\x0fcamera_position\x18\x02\x20\x01(\x0b2\x10.Read\
    OnlyVector3R\x0ecameraPosition\x12#\n\rplayer_height\x18\x03\x20\x01(\
    \x02R\x0cplayerHeight\"{\n\x16RotationChangedPayload\x12,\n\x08rotation\
    \x18\x01\x20\x01(\x0b2\x10.ReadOnlyVector3R\x08rotation\x123\n\nquaterni\
    on\x18\x02\x20\x01(\x0b2\x13.ReadOnlyQuaternionR\nquaternion\"\xa7\x02\n\
    \tEventData\x12\"\n\x04type\x18\x01\x20\x01(\x0e2\x0e.EventDataTypeR\x04\
    type\x12.\n\x07generic\x18\x02\x20\x01(\x0b2\x0f.GenericPayloadH\0R\x07g\
    eneric\x88\x01\x01\x12G\n\x10position_changed\x18\x03\x20\x01(\x0b2\x17.\
    PositionChangedPayloadH\x01R\x0fpositionChanged\x88\x01\x01\x12G\n\x10ro\
    tation_changed\x18\x04\x20\x01(\x0b2\x17.RotationChangedPayloadH\x02R\
    \x0frotationChanged\x88\x01\x01B\n\n\x08_genericB\x13\n\x11_position_cha\
    ngedB\x13\n\x11_rotation_changed*b\n\tQueryType\x12\x14\n\x10InvalidQuer\
    yType\x10\0\x12\x0c\n\x08HitFirst\x10\x01\x12\n\n\x06HitAll\x10\x02\x12\
    \x12\n\x0eHitFirstAvatar\x10\x03\x12\x11\n\rHitAllAvatars\x10\x04*\xb0\
    \x02\n\x06EAType\x12\x11\n\rInvalidEAType\x10\0\x12\x13\n\x0fOpenExterna\
    lUrl\x10\x01\x12\x11\n\rOpenNFTDialog\x10\x02\x12\x10\n\x0cCreateEntity\
    \x10\x03\x12\x10\n\x0cRemoveEntity\x10\x04\x12\x19\n\x15UpdateEntityComp\
    onent\x10\x05\x12\x19\n\x15AttachEntityComponent\x10\x06\x12\x14\n\x10Co\
    mponentRemoved\x10\x07\x12\x13\n\x0fSetEntityParent\x10\x08\x12\t\n\x05Q\
    uery\x10\t\x12\x14\n\x10ComponentCreated\x10\n\x12\x15\n\x11ComponentDis\
    posed\x10\x0b\x12\x14\n\x10ComponentUpdated\x10\x0c\x12\x18\n\x14InitMes\
    sagesFinished\x10\r*F\n\rEventDataType\x12\x0b\n\x07Generic\x10\0\x12\
    \x13\n\x0fPositionChanged\x10\x01\x12\x13\n\x0fRotationChanged\x10\x022\
    \xba\x01\n\x10EngineAPIService\x124\n\tSendBatch\x12\x11.ManyEntityActio\
    n\x1a\x12.SendBatchResponse\"\0\x124\n\tSubscribe\x12\x11.SubscribeReque\
    st\x1a\x12.SubscribeResponse\"\0\x12:\n\x0bUnsubscribe\x12\x13.Unsubscri\
    beRequest\x1a\x14.UnsubscribeResponse\"\0J\xcb,\n\x07\x12\x05\0\0\xb3\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\n\n\x02\x04\0\x12\x04\x02\0\
    \x04\x01\n\n\n\x03\x04\0\x01\x12\x03\x02\x08\x1b\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03\x03\x04\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x03\x04\n\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x03\x0b\x0e\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x03\x11\x12\n\n\n\x02\x04\x01\x12\x04\x06\0\n\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03\x06\x08\x19\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x07\x04&\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x07\x04\n\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x07\x0b!\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x07$%\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03\x08\x04\x18\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03\x08\x04\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x08\
    \x0b\x13\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x08\x16\x17\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x03\t\x04\x20\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\
    \x03\t\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\t\r\x13\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03\t\x14\x1b\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03\t\x1e\x1f\n\n\n\x02\x04\x02\x12\x04\x0c\0\x0e\x01\n\n\n\x03\
    \x04\x02\x01\x12\x03\x0c\x08\x18\n\x0b\n\x04\x04\x02\x02\0\x12\x03\r\x04\
    \x12\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\r\x04\n\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03\r\x0b\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\r\x10\
    \x11\n\n\n\x02\x04\x03\x12\x04\x10\0\x12\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03\x10\x08\x18\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x11\x04\x12\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x03\x11\x04\n\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03\x11\x0b\r\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x11\x10\x11\n\n\
    \n\x02\x04\x04\x12\x04\x14\0\x19\x01\n\n\n\x03\x04\x04\x01\x12\x03\x14\
    \x08!\n\x0b\n\x04\x04\x04\x02\0\x12\x03\x15\x04\x19\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03\x15\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\x15\
    \x0b\x14\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x15\x17\x18\n\x0b\n\x04\
    \x04\x04\x02\x01\x12\x03\x16\x04\x17\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03\x16\x04\t\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03\x16\n\x12\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03\x16\x15\x16\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03\x17\x04\x14\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03\x17\x04\n\n\
    \x0c\n\x05\x04\x04\x02\x02\x01\x12\x03\x17\x0b\x0f\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03\x17\x12\x13\n\x0b\n\x04\x04\x04\x02\x03\x12\x03\x18\
    \x04\x14\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03\x18\x04\n\n\x0c\n\x05\
    \x04\x04\x02\x03\x01\x12\x03\x18\x0b\x0f\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03\x18\x12\x13\n\n\n\x02\x04\x05\x12\x04\x1b\0\x1f\x01\n\n\n\x03\
    \x04\x05\x01\x12\x03\x1b\x08!\n\x0b\n\x04\x04\x05\x02\0\x12\x03\x1c\x04\
    \x19\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03\x1c\x04\n\n\x0c\n\x05\x04\x05\
    \x02\0\x01\x12\x03\x1c\x0b\x14\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03\x1c\
    \x17\x18\n\x0b\n\x04\x04\x05\x02\x01\x12\x03\x1d\x04\x14\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03\x1d\x04\n\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\
    \x03\x1d\x0b\x0f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03\x1d\x12\x13\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03\x1e\x04\x12\n\x0c\n\x05\x04\x05\x02\
    \x02\x05\x12\x03\x1e\x04\n\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03\x1e\
    \x0b\r\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03\x1e\x10\x11\n\n\n\x02\x04\
    \x06\x12\x04!\0$\x01\n\n\n\x03\x04\x06\x01\x12\x03!\x08\x1c\n\x0b\n\x04\
    \x04\x06\x02\0\x12\x03\"\x04\x19\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03\"\
    \x04\n\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03\"\x0b\x14\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x03\"\x17\x18\n\x0b\n\x04\x04\x06\x02\x01\x12\x03#\
    \x04\x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03#\x04\n\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03#\x0b\x0f\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03#\x12\x13\n\n\n\x02\x04\x07\x12\x04&\0)\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03&\x08\x1b\n\x0b\n\x04\x04\x07\x02\0\x12\x03'\x04\x19\n\x0c\n\x05\
    \x04\x07\x02\0\x05\x12\x03'\x04\n\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03'\
    \x0b\x14\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03'\x17\x18\n\x0b\n\x04\x04\
    \x07\x02\x01\x12\x03(\x04\x19\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03(\
    \x04\n\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03(\x0b\x14\n\x0c\n\x05\x04\
    \x07\x02\x01\x03\x12\x03(\x17\x18\n\n\n\x02\x05\0\x12\x04+\01\x01\n\n\n\
    \x03\x05\0\x01\x12\x03+\x05\x0e\n\x0b\n\x04\x05\0\x02\0\x12\x03,\x04\x19\
    \n\x0c\n\x05\x05\0\x02\0\x01\x12\x03,\x04\x14\n\x0c\n\x05\x05\0\x02\0\
    \x02\x12\x03,\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03-\x04\x11\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03-\x04\x0c\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03-\x0f\x10\n\x0b\n\x04\x05\0\x02\x02\x12\x03.\x04\x0f\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03.\x04\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03.\
    \r\x0e\n\x0b\n\x04\x05\0\x02\x03\x12\x03/\x04\x17\n\x0c\n\x05\x05\0\x02\
    \x03\x01\x12\x03/\x04\x12\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03/\x15\x16\
    \n\x0b\n\x04\x05\0\x02\x04\x12\x030\x04\x16\n\x0c\n\x05\x05\0\x02\x04\
    \x01\x12\x030\x04\x11\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x030\x14\x15\n\n\
    \n\x02\x04\x08\x12\x043\06\x01\n\n\n\x03\x04\x08\x01\x12\x033\x08\x11\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x034\x04\x1b\n\x0c\n\x05\x04\x08\x02\0\x06\
    \x12\x034\x04\r\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x034\x0e\x16\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x034\x19\x1a\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x035\x04\x17\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x035\x04\n\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x035\x0b\x12\n\x0c\n\x05\x04\x08\x02\x01\x03\
    \x12\x035\x15\x16\n\n\n\x02\x04\t\x12\x048\0<\x01\n\n\n\x03\x04\t\x01\
    \x12\x038\x08\x1c\n\x0b\n\x04\x04\t\x02\0\x12\x039\x04\x12\n\x0c\n\x05\
    \x04\t\x02\0\x05\x12\x039\x04\n\n\x0c\n\x05\x04\t\x02\0\x01\x12\x039\x0b\
    \r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x039\x10\x11\n\x0b\n\x04\x04\t\x02\
    \x01\x12\x03:\x04\x17\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03:\x04\t\n\x0c\
    \n\x05\x04\t\x02\x01\x01\x12\x03:\n\x12\n\x0c\n\x05\x04\t\x02\x01\x03\
    \x12\x03:\x15\x16\n\x0b\n\x04\x04\t\x02\x02\x12\x03;\x04\x14\n\x0c\n\x05\
    \x04\t\x02\x02\x05\x12\x03;\x04\n\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03;\
    \x0b\x0f\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03;\x12\x13\n\n\n\x02\x04\n\
    \x12\x04>\0@\x01\n\n\n\x03\x04\n\x01\x12\x03>\x08\x1d\n\x0b\n\x04\x04\n\
    \x02\0\x12\x03?\x04\x12\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03?\x04\n\n\x0c\
    \n\x05\x04\n\x02\0\x01\x12\x03?\x0b\r\n\x0c\n\x05\x04\n\x02\0\x03\x12\
    \x03?\x10\x11\n\n\n\x02\x04\x0b\x12\x04B\0E\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03B\x08\x1c\n\x0b\n\x04\x04\x0b\x02\0\x12\x03C\x04\x12\n\x0c\n\x05\
    \x04\x0b\x02\0\x05\x12\x03C\x04\n\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03C\
    \x0b\r\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03C\x10\x11\n\x0b\n\x04\x04\
    \x0b\x02\x01\x12\x03D\x04\x14\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03D\
    \x04\n\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03D\x0b\x0f\n\x0c\n\x05\x04\
    \x0b\x02\x01\x03\x12\x03D\x12\x13\n\n\n\x02\x04\x0c\x12\x04G\0I\x01\n\n\
    \n\x03\x04\x0c\x01\x12\x03G\x08\x20\n\n\n\x02\x04\r\x12\x04K\0Y\x01\n\n\
    \n\x03\x04\r\x01\x12\x03K\x08\x0f\n\x0b\n\x04\x04\r\x02\0\x12\x03L\x047\
    \n\x0c\n\x05\x04\r\x02\0\x04\x12\x03L\x04\x0c\n\x0c\n\x05\x04\r\x02\0\
    \x06\x12\x03L\r\x20\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03L!2\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03L56\n\x0b\n\x04\x04\r\x02\x01\x12\x03M\x043\n\
    \x0c\n\x05\x04\r\x02\x01\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\r\x02\x01\
    \x06\x12\x03M\r\x1e\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03M\x1f.\n\x0c\n\
    \x05\x04\r\x02\x01\x03\x12\x03M12\n\x0b\n\x04\x04\r\x02\x02\x12\x03N\x04\
    0\n\x0c\n\x05\x04\r\x02\x02\x04\x12\x03N\x04\x0c\n\x0c\n\x05\x04\r\x02\
    \x02\x06\x12\x03N\r\x1d\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03N\x1e+\n\
    \x0c\n\x05\x04\r\x02\x02\x03\x12\x03N./\n\x0b\n\x04\x04\r\x02\x03\x12\
    \x03O\x040\n\x0c\n\x05\x04\r\x02\x03\x04\x12\x03O\x04\x0c\n\x0c\n\x05\
    \x04\r\x02\x03\x06\x12\x03O\r\x1d\n\x0c\n\x05\x04\r\x02\x03\x01\x12\x03O\
    \x1e+\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03O./\n\x0b\n\x04\x04\r\x02\x04\
    \x12\x03P\x04C\n\x0c\n\x05\x04\r\x02\x04\x04\x12\x03P\x04\x0c\n\x0c\n\
    \x05\x04\r\x02\x04\x06\x12\x03P\r&\n\x0c\n\x05\x04\r\x02\x04\x01\x12\x03\
    P'>\n\x0c\n\x05\x04\r\x02\x04\x03\x12\x03PAB\n\x0b\n\x04\x04\r\x02\x05\
    \x12\x03Q\x04C\n\x0c\n\x05\x04\r\x02\x05\x04\x12\x03Q\x04\x0c\n\x0c\n\
    \x05\x04\r\x02\x05\x06\x12\x03Q\r&\n\x0c\n\x05\x04\r\x02\x05\x01\x12\x03\
    Q'>\n\x0c\n\x05\x04\r\x02\x05\x03\x12\x03QAB\n\x0b\n\x04\x04\r\x02\x06\
    \x12\x03R\x048\n\x0c\n\x05\x04\r\x02\x06\x04\x12\x03R\x04\x0c\n\x0c\n\
    \x05\x04\r\x02\x06\x06\x12\x03R\r!\n\x0c\n\x05\x04\r\x02\x06\x01\x12\x03\
    R\"3\n\x0c\n\x05\x04\r\x02\x06\x03\x12\x03R67\n\x0b\n\x04\x04\r\x02\x07\
    \x12\x03S\x047\n\x0c\n\x05\x04\r\x02\x07\x04\x12\x03S\x04\x0c\n\x0c\n\
    \x05\x04\r\x02\x07\x06\x12\x03S\r\x20\n\x0c\n\x05\x04\r\x02\x07\x01\x12\
    \x03S!2\n\x0c\n\x05\x04\r\x02\x07\x03\x12\x03S56\n\x0b\n\x04\x04\r\x02\
    \x08\x12\x03T\x04!\n\x0c\n\x05\x04\r\x02\x08\x04\x12\x03T\x04\x0c\n\x0c\
    \n\x05\x04\r\x02\x08\x06\x12\x03T\r\x16\n\x0c\n\x05\x04\r\x02\x08\x01\
    \x12\x03T\x17\x1c\n\x0c\n\x05\x04\r\x02\x08\x03\x12\x03T\x1f\x20\n\x0b\n\
    \x04\x04\r\x02\t\x12\x03U\x049\n\x0c\n\x05\x04\r\x02\t\x04\x12\x03U\x04\
    \x0c\n\x0c\n\x05\x04\r\x02\t\x06\x12\x03U\r!\n\x0c\n\x05\x04\r\x02\t\x01\
    \x12\x03U\"3\n\x0c\n\x05\x04\r\x02\t\x03\x12\x03U68\n\x0b\n\x04\x04\r\
    \x02\n\x12\x03V\x04;\n\x0c\n\x05\x04\r\x02\n\x04\x12\x03V\x04\x0c\n\x0c\
    \n\x05\x04\r\x02\n\x06\x12\x03V\r\"\n\x0c\n\x05\x04\r\x02\n\x01\x12\x03V\
    #5\n\x0c\n\x05\x04\r\x02\n\x03\x12\x03V8:\n\x0b\n\x04\x04\r\x02\x0b\x12\
    \x03W\x049\n\x0c\n\x05\x04\r\x02\x0b\x04\x12\x03W\x04\x0c\n\x0c\n\x05\
    \x04\r\x02\x0b\x06\x12\x03W\r!\n\x0c\n\x05\x04\r\x02\x0b\x01\x12\x03W\"3\
    \n\x0c\n\x05\x04\r\x02\x0b\x03\x12\x03W68\n\x0b\n\x04\x04\r\x02\x0c\x12\
    \x03X\x04B\n\x0c\n\x05\x04\r\x02\x0c\x04\x12\x03X\x04\x0c\n\x0c\n\x05\
    \x04\r\x02\x0c\x06\x12\x03X\r%\n\x0c\n\x05\x04\r\x02\x0c\x01\x12\x03X&<\
    \n\x0c\n\x05\x04\r\x02\x0c\x03\x12\x03X?A\n\n\n\x02\x05\x01\x12\x04[\0j\
    \x01\n\n\n\x03\x05\x01\x01\x12\x03[\x05\x0b\n\x0b\n\x04\x05\x01\x02\0\
    \x12\x03\\\x04\x16\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\\\x04\x11\n\x0c\
    \n\x05\x05\x01\x02\0\x02\x12\x03\\\x14\x15\n\x0b\n\x04\x05\x01\x02\x01\
    \x12\x03]\x04\x18\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03]\x04\x13\n\x0c\
    \n\x05\x05\x01\x02\x01\x02\x12\x03]\x16\x17\n\x0b\n\x04\x05\x01\x02\x02\
    \x12\x03^\x04\x16\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03^\x04\x11\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03^\x14\x15\n\x0b\n\x04\x05\x01\x02\x03\
    \x12\x03_\x04\x15\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03_\x04\x10\n\x0c\
    \n\x05\x05\x01\x02\x03\x02\x12\x03_\x13\x14\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03`\x04\x15\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03`\x04\x10\n\x0c\
    \n\x05\x05\x01\x02\x04\x02\x12\x03`\x13\x14\n\x0b\n\x04\x05\x01\x02\x05\
    \x12\x03a\x04\x1e\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03a\x04\x19\n\x0c\
    \n\x05\x05\x01\x02\x05\x02\x12\x03a\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x06\
    \x12\x03b\x04\x1e\n\x0c\n\x05\x05\x01\x02\x06\x01\x12\x03b\x04\x19\n\x0c\
    \n\x05\x05\x01\x02\x06\x02\x12\x03b\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x07\
    \x12\x03c\x04\x19\n\x0c\n\x05\x05\x01\x02\x07\x01\x12\x03c\x04\x14\n\x0c\
    \n\x05\x05\x01\x02\x07\x02\x12\x03c\x17\x18\n\x0b\n\x04\x05\x01\x02\x08\
    \x12\x03d\x04\x18\n\x0c\n\x05\x05\x01\x02\x08\x01\x12\x03d\x04\x13\n\x0c\
    \n\x05\x05\x01\x02\x08\x02\x12\x03d\x16\x17\n\x0b\n\x04\x05\x01\x02\t\
    \x12\x03e\x04\x0e\n\x0c\n\x05\x05\x01\x02\t\x01\x12\x03e\x04\t\n\x0c\n\
    \x05\x05\x01\x02\t\x02\x12\x03e\x0c\r\n\x0b\n\x04\x05\x01\x02\n\x12\x03f\
    \x04\x1a\n\x0c\n\x05\x05\x01\x02\n\x01\x12\x03f\x04\x14\n\x0c\n\x05\x05\
    \x01\x02\n\x02\x12\x03f\x17\x19\n\x0b\n\x04\x05\x01\x02\x0b\x12\x03g\x04\
    \x1b\n\x0c\n\x05\x05\x01\x02\x0b\x01\x12\x03g\x04\x15\n\x0c\n\x05\x05\
    \x01\x02\x0b\x02\x12\x03g\x18\x1a\n\x0b\n\x04\x05\x01\x02\x0c\x12\x03h\
    \x04\x1a\n\x0c\n\x05\x05\x01\x02\x0c\x01\x12\x03h\x04\x14\n\x0c\n\x05\
    \x05\x01\x02\x0c\x02\x12\x03h\x17\x19\n\x0b\n\x04\x05\x01\x02\r\x12\x03i\
    \x04\x1e\n\x0c\n\x05\x05\x01\x02\r\x01\x12\x03i\x04\x18\n\x0c\n\x05\x05\
    \x01\x02\r\x02\x12\x03i\x1b\x1d\n\n\n\x02\x04\x0e\x12\x04l\0p\x01\n\n\n\
    \x03\x04\x0e\x01\x12\x03l\x08\x14\n\x0b\n\x04\x04\x0e\x02\0\x12\x03m\x04\
    \x14\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\x03m\x04\n\n\x0c\n\x05\x04\x0e\
    \x02\0\x01\x12\x03m\x0b\x0f\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03m\x12\
    \x13\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03n\x04\x1c\n\x0c\n\x05\x04\x0e\
    \x02\x01\x04\x12\x03n\x04\x0c\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03n\r\
    \x13\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03n\x14\x17\n\x0c\n\x05\x04\
    \x0e\x02\x01\x03\x12\x03n\x1a\x1b\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03o\
    \x04\x18\n\x0c\n\x05\x04\x0e\x02\x02\x06\x12\x03o\x04\x0b\n\x0c\n\x05\
    \x04\x0e\x02\x02\x01\x12\x03o\x0c\x13\n\x0c\n\x05\x04\x0e\x02\x02\x03\
    \x12\x03o\x16\x17\n\n\n\x02\x04\x0f\x12\x04r\0t\x01\n\n\n\x03\x04\x0f\
    \x01\x12\x03r\x08\x18\n\x0b\n\x04\x04\x0f\x02\0\x12\x03s\x04&\n\x0c\n\
    \x05\x04\x0f\x02\0\x04\x12\x03s\x04\x0c\n\x0c\n\x05\x04\x0f\x02\0\x06\
    \x12\x03s\r\x19\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03s\x1a!\n\x0c\n\x05\
    \x04\x0f\x02\0\x03\x12\x03s$%\n\n\n\x02\x04\x10\x12\x04v\0x\x01\n\n\n\
    \x03\x04\x10\x01\x12\x03v\x08\x19\n\x0b\n\x04\x04\x10\x02\0\x12\x03w\x02\
    \x20\n\x0c\n\x05\x04\x10\x02\0\x04\x12\x03w\x02\n\n\x0c\n\x05\x04\x10\
    \x02\0\x06\x12\x03w\x0b\x14\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03w\x15\
    \x1b\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03w\x1e\x1f\n\n\n\x02\x04\x11\
    \x12\x04z\0|\x01\n\n\n\x03\x04\x11\x01\x12\x03z\x08\x1a\n\x0b\n\x04\x04\
    \x11\x02\0\x12\x03{\x04\x18\n\x0c\n\x05\x04\x11\x02\0\x05\x12\x03{\x04\n\
    \n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03{\x0b\x13\n\x0c\n\x05\x04\x11\x02\
    \0\x03\x12\x03{\x16\x17\n\n\n\x02\x04\x12\x12\x04}\0\x7f\x01\n\n\n\x03\
    \x04\x12\x01\x12\x03}\x08\x18\n\x0b\n\x04\x04\x12\x02\0\x12\x03~\x04\x18\
    \n\x0c\n\x05\x04\x12\x02\0\x05\x12\x03~\x04\n\n\x0c\n\x05\x04\x12\x02\0\
    \x01\x12\x03~\x0b\x13\n\x0c\n\x05\x04\x12\x02\0\x03\x12\x03~\x16\x17\n\n\
    \n\x02\x04\x13\x12\x04\x80\x01\0\x1c\n\x0b\n\x03\x04\x13\x01\x12\x04\x80\
    \x01\x08\x19\n\n\n\x02\x04\x14\x12\x04\x81\x01\0\x1e\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\x81\x01\x08\x1b\n\x16\n\x02\x05\x02\x12\x06\x85\x01\0\x89\
    \x01\x01\x1a\x08\x20Events\n\n\x0b\n\x03\x05\x02\x01\x12\x04\x85\x01\x05\
    \x12\n\x0c\n\x04\x05\x02\x02\0\x12\x04\x86\x01\x04\x10\n\r\n\x05\x05\x02\
    \x02\0\x01\x12\x04\x86\x01\x04\x0b\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\
    \x86\x01\x0e\x0f\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\x87\x01\x04\x18\n\r\
    \n\x05\x05\x02\x02\x01\x01\x12\x04\x87\x01\x04\x13\n\r\n\x05\x05\x02\x02\
    \x01\x02\x12\x04\x87\x01\x16\x17\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\x88\
    \x01\x04\x18\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\x88\x01\x04\x13\n\r\n\
    \x05\x05\x02\x02\x02\x02\x12\x04\x88\x01\x16\x17\n\x0c\n\x02\x04\x15\x12\
    \x06\x8b\x01\0\x8e\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x8b\x01\x08\
    \x16\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x8c\x01\x04\x18\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\x8c\x01\x04\n\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x8c\
    \x01\x0b\x13\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x8c\x01\x16\x17\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\x8d\x01\x04\x1a\n\r\n\x05\x04\x15\x02\x01\
    \x05\x12\x04\x8d\x01\x04\n\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x8d\x01\
    \x0b\x15\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x8d\x01\x18\x19\n\x0c\n\
    \x02\x04\x16\x12\x06\x90\x01\0\x94\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x90\x01\x08\x17\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x91\x01\x04\x10\n\
    \r\n\x05\x04\x16\x02\0\x05\x12\x04\x91\x01\x04\t\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\x91\x01\n\x0b\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x91\x01\
    \x0e\x0f\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x92\x01\x04\x10\n\r\n\x05\
    \x04\x16\x02\x01\x05\x12\x04\x92\x01\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\x92\x01\n\x0b\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x92\x01\x0e\
    \x0f\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\x93\x01\x04\x10\n\r\n\x05\x04\
    \x16\x02\x02\x05\x12\x04\x93\x01\x04\t\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\x93\x01\n\x0b\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\x93\x01\x0e\x0f\
    \n\x0c\n\x02\x04\x17\x12\x06\x96\x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x17\
    \x01\x12\x04\x96\x01\x08\x1a\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x97\x01\
    \x04\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x97\x01\x04\t\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\x97\x01\n\x0b\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \x97\x01\x0e\x0f\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x98\x01\x04\x10\n\r\
    \n\x05\x04\x17\x02\x01\x05\x12\x04\x98\x01\x04\t\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x98\x01\n\x0b\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x98\
    \x01\x0e\x0f\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\x99\x01\x04\x10\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\x99\x01\x04\t\n\r\n\x05\x04\x17\x02\x02\
    \x01\x12\x04\x99\x01\n\x0b\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x99\x01\
    \x0e\x0f\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\x9a\x01\x04\x10\n\r\n\x05\
    \x04\x17\x02\x03\x05\x12\x04\x9a\x01\x04\t\n\r\n\x05\x04\x17\x02\x03\x01\
    \x12\x04\x9a\x01\n\x0b\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x9a\x01\x0e\
    \x0f\n\x0c\n\x02\x04\x18\x12\x06\x9d\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\x9d\x01\x08\x1e\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x9e\
    \x01\x04!\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x9e\x01\x04\x13\n\r\n\x05\
    \x04\x18\x02\0\x01\x12\x04\x9e\x01\x14\x1c\n\r\n\x05\x04\x18\x02\0\x03\
    \x12\x04\x9e\x01\x1f\x20\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x9f\x01\x04\
    (\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\x9f\x01\x04\x13\n\r\n\x05\x04\
    \x18\x02\x01\x01\x12\x04\x9f\x01\x14#\n\r\n\x05\x04\x18\x02\x01\x03\x12\
    \x04\x9f\x01&'\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xa0\x01\x04\x1c\n\r\n\
    \x05\x04\x18\x02\x02\x05\x12\x04\xa0\x01\x04\t\n\r\n\x05\x04\x18\x02\x02\
    \x01\x12\x04\xa0\x01\n\x17\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xa0\x01\
    \x1a\x1b\n\x0c\n\x02\x04\x19\x12\x06\xa3\x01\0\xa6\x01\x01\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\xa3\x01\x08\x1e\n\x0c\n\x04\x04\x19\x02\0\x12\x04\
    \xa4\x01\x04!\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xa4\x01\x04\x13\n\r\n\
    \x05\x04\x19\x02\0\x01\x12\x04\xa4\x01\x14\x1c\n\r\n\x05\x04\x19\x02\0\
    \x03\x12\x04\xa4\x01\x1f\x20\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xa5\x01\
    \x04&\n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\xa5\x01\x04\x16\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xa5\x01\x17!\n\r\n\x05\x04\x19\x02\x01\x03\
    \x12\x04\xa5\x01$%\n\x0c\n\x02\x04\x1a\x12\x06\xa8\x01\0\xad\x01\x01\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xa8\x01\x08\x11\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\xa9\x01\x04\x1b\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xa9\x01\x04\
    \x11\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xa9\x01\x12\x16\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\xa9\x01\x19\x1a\n\x0c\n\x04\x04\x1a\x02\x01\x12\
    \x04\xaa\x01\x04(\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xaa\x01\x04\x0c\
    \n\r\n\x05\x04\x1a\x02\x01\x06\x12\x04\xaa\x01\r\x1b\n\r\n\x05\x04\x1a\
    \x02\x01\x01\x12\x04\xaa\x01\x1c#\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\
    \xaa\x01&'\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xab\x01\x049\n\r\n\x05\
    \x04\x1a\x02\x02\x04\x12\x04\xab\x01\x04\x0c\n\r\n\x05\x04\x1a\x02\x02\
    \x06\x12\x04\xab\x01\r#\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xab\x01$4\
    \n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xab\x0178\n\x0c\n\x04\x04\x1a\x02\
    \x03\x12\x04\xac\x01\x049\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xac\x01\
    \x04\x0c\n\r\n\x05\x04\x1a\x02\x03\x06\x12\x04\xac\x01\r#\n\r\n\x05\x04\
    \x1a\x02\x03\x01\x12\x04\xac\x01$4\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\
    \xac\x0178\n\x0c\n\x02\x06\0\x12\x06\xaf\x01\0\xb3\x01\x01\n\x0b\n\x03\
    \x06\0\x01\x12\x04\xaf\x01\x08\x18\n\x0c\n\x04\x06\0\x02\0\x12\x04\xb0\
    \x01\x02@\n\r\n\x05\x06\0\x02\0\x01\x12\x04\xb0\x01\x06\x0f\n\r\n\x05\
    \x06\0\x02\0\x02\x12\x04\xb0\x01\x10\x20\n\r\n\x05\x06\0\x02\0\x03\x12\
    \x04\xb0\x01+<\n\x0c\n\x04\x06\0\x02\x01\x12\x04\xb1\x01\x02@\n\r\n\x05\
    \x06\0\x02\x01\x01\x12\x04\xb1\x01\x06\x0f\n\r\n\x05\x06\0\x02\x01\x02\
    \x12\x04\xb1\x01\x10\x20\n\r\n\x05\x06\0\x02\x01\x03\x12\x04\xb1\x01+<\n\
    \x0c\n\x04\x06\0\x02\x02\x12\x04\xb2\x01\x02F\n\r\n\x05\x06\0\x02\x02\
    \x01\x12\x04\xb2\x01\x06\x11\n\r\n\x05\x06\0\x02\x02\x02\x12\x04\xb2\x01\
    \x12$\n\r\n\x05\x06\0\x02\x02\x03\x12\x04\xb2\x01/Bb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(OpenExternalUrlBody::generated_message_descriptor_data());
            messages.push(OpenNFTDialogBody::generated_message_descriptor_data());
            messages.push(CreateEntityBody::generated_message_descriptor_data());
            messages.push(RemoveEntityBody::generated_message_descriptor_data());
            messages.push(UpdateEntityComponentBody::generated_message_descriptor_data());
            messages.push(AttachEntityComponentBody::generated_message_descriptor_data());
            messages.push(ComponentRemovedBody::generated_message_descriptor_data());
            messages.push(SetEntityParentBody::generated_message_descriptor_data());
            messages.push(QueryBody::generated_message_descriptor_data());
            messages.push(ComponentCreatedBody::generated_message_descriptor_data());
            messages.push(ComponentDisposedBody::generated_message_descriptor_data());
            messages.push(ComponentUpdatedBody::generated_message_descriptor_data());
            messages.push(InitMessagesFinishedBody::generated_message_descriptor_data());
            messages.push(Payload::generated_message_descriptor_data());
            messages.push(EntityAction::generated_message_descriptor_data());
            messages.push(ManyEntityAction::generated_message_descriptor_data());
            messages.push(SendBatchResponse::generated_message_descriptor_data());
            messages.push(UnsubscribeRequest::generated_message_descriptor_data());
            messages.push(SubscribeRequest::generated_message_descriptor_data());
            messages.push(SubscribeResponse::generated_message_descriptor_data());
            messages.push(UnsubscribeResponse::generated_message_descriptor_data());
            messages.push(GenericPayload::generated_message_descriptor_data());
            messages.push(ReadOnlyVector3::generated_message_descriptor_data());
            messages.push(ReadOnlyQuaternion::generated_message_descriptor_data());
            messages.push(PositionChangedPayload::generated_message_descriptor_data());
            messages.push(RotationChangedPayload::generated_message_descriptor_data());
            messages.push(EventData::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(QueryType::generated_enum_descriptor_data());
            enums.push(EAType::generated_enum_descriptor_data());
            enums.push(EventDataType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
